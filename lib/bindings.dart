// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int core_init(
    ffi.Pointer<maid_params> mparams,
    ffi.Pointer<maid_logger> log_output,
  ) {
    return _core_init(
      mparams,
      log_output,
    );
  }

  late final _core_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<maid_params>,
              ffi.Pointer<maid_logger>)>>('core_init');
  late final _core_init = _core_initPtr.asFunction<
      int Function(ffi.Pointer<maid_params>, ffi.Pointer<maid_logger>)>();

  int core_prompt(
    ffi.Pointer<ffi.Char> input,
    ffi.Pointer<maid_output_stream> maid_output,
  ) {
    return _core_prompt(
      input,
      maid_output,
    );
  }

  late final _core_promptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<maid_output_stream>)>>('core_prompt');
  late final _core_prompt = _core_promptPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<maid_output_stream>)>();

  void core_stop() {
    return _core_stop();
  }

  late final _core_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('core_stop');
  late final _core_stop = _core_stopPtr.asFunction<void Function()>();

  void core_cleanup() {
    return _core_cleanup();
  }

  late final _core_cleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('core_cleanup');
  late final _core_cleanup = _core_cleanupPtr.asFunction<void Function()>();
}

final class maid_params extends ffi.Struct {
  @ffi.UnsignedChar()
  external int instruct;

  @ffi.UnsignedChar()
  external int interactive;

  @ffi.UnsignedChar()
  external int chatml;

  external ffi.Pointer<ffi.Char> path;

  external ffi.Pointer<ffi.Char> preprompt;

  external ffi.Pointer<ffi.Char> input_prefix;

  external ffi.Pointer<ffi.Char> input_suffix;

  @ffi.UnsignedInt()
  external int seed;

  @ffi.Int()
  external int n_ctx;

  @ffi.Int()
  external int n_batch;

  @ffi.Int()
  external int n_threads;

  @ffi.Int()
  external int n_predict;

  @ffi.Int()
  external int n_keep;

  @ffi.Int()
  external int top_k;

  @ffi.Float()
  external double top_p;

  @ffi.Float()
  external double min_p;

  @ffi.Float()
  external double tfs_z;

  @ffi.Float()
  external double typical_p;

  @ffi.Float()
  external double temp;

  @ffi.Int()
  external int penalty_last_n;

  @ffi.Float()
  external double penalty_repeat;

  @ffi.Float()
  external double penalty_freq;

  @ffi.Float()
  external double penalty_present;

  @ffi.Int()
  external int mirostat;

  @ffi.Float()
  external double mirostat_tau;

  @ffi.Float()
  external double mirostat_eta;

  @ffi.UnsignedChar()
  external int penalize_nl;
}

abstract class return_code {
  static const int STOP = 0;
  static const int CONTINUE = 1;
}

typedef maid_logger
    = ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char> buffer)>;
typedef maid_output_stream = ffi.NativeFunction<
    ffi.Void Function(ffi.UnsignedChar code, ffi.Pointer<ffi.Char> buffer)>;
